/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./client/assetloader.js":
/*!*******************************!*\
  !*** ./client/assetloader.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("class AssetLoader {\n    static blocks = {};\n    static assets = {};\n\n    static loadBlocks(...names) {\n        names.forEach((name) => {\n            const block = __webpack_require__(\"./client/blocks sync recursive ^\\\\.\\\\/.*\\\\.js$\")(`./${name}.js`);\n            this.blocks[name] = block;\n        })\n    }\n\n    static getIdForBlock(name) {\n        if(typeof name != \"string\") return name;\n\n        let block = this.blocks[name];\n        return block?.id ?? null;\n    }\n\n    static getNameForBlock(id) {\n        if(typeof id == \"string\") return id;\n\n        for(let name of Object.keys(this.blocks)) {\n            if(this.blocks[name].id == id) return name;\n        }\n    }\n\n    static async loadAssets(...names) {\n        let promises = [];\n        \n        for(let name of names) {\n            promises.push(new Promise((res,rej) => {\n                let img = new Image();\n                img.onload = () => {\n                    this.assets[name] = img;\n                    res(img);\n                }\n                img.src = `/assets/${name}.png`;\n            }));\n        }\n\n        for(let promise of promises) {\n            await promise;\n        }\n    }\n\n    static async loadDefault() {\n\n        this.loadBlocks(\n            \"brick\",\"spike\",\"flag\",\"chain\",\"metal\",\"water\",\n            \"invisible\",\"bouncepad\",\"jumporb\",\"grate\",\"roundspike\",\n            \"spawnpoint\",\"lava\",\"forcefield\",\"wood\",\"gravityorb\",\n            \"levetatingblock\",\"sludge\",\"flagblock\",\"spawnpointblock\",\n            \"technochain\",\"technometal\",\"blue\",\"lock\",\"fireballshooter\",\n\n            \"icon-experimental\"\n        );\n        await this.loadAssets(\n            \"menu/debug\", \"menu/eraser\", \"menu/exit\", \"menu/handle\",\n            \"menu/import\", \"menu/save\", \"menu/settings\", \"menu/spawn\",\n            \"menu/start\", \"menu/stop\", \"basicCursor\", \"brushCursor\",\n            \"player\", \"menu/experimental\"\n        );\n    }\n}\n\nmodule.exports = AssetLoader;\n\n//# sourceURL=webpack://arlosmod/./client/assetloader.js?");

/***/ }),

/***/ "./client/blocks/block.js":
/*!********************************!*\
  !*** ./client/blocks/block.js ***!
  \********************************/
/***/ ((module) => {

eval("module.exports = class Block {\n    static displayname = \"block\";\n    static description = \"default description\"\n    static id = 0;\n    static rotatable = false;\n\n    static onEntityHit(entity, collision) {\n\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/block.js?");

/***/ }),

/***/ "./client/blocks/blue.js":
/*!*******************************!*\
  !*** ./client/blocks/blue.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Blue extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Blue\";\n    static description = \"Blue\";\n    static id = 23;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/blue.js?");

/***/ }),

/***/ "./client/blocks/bouncepad.js":
/*!************************************!*\
  !*** ./client/blocks/bouncepad.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class BouncePad extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Bounce Pad\";\n    static description = \"Bounces the player up by a normal amount\";\n    static id = 7;\n    static rotatable = true;\n\n    static onEntityHit(entity, collision) {\n        let ex = entity.x;\n        let ey = entity.y;\n        let ew = entity.width;\n        let eh = entity.height;\n        let tx = collision.tile.x;\n        let ty = collision.tile.y;\n\n        setTimeout(() => {\n            switch(collision.tile.rotation) {\n                case 0:\n                    if(ey + eh/2 < ty + 0.1 && entity.motionY > -0.1) entity.motionY = -30;\n                    break;\n                case 1:\n                    if(ex - ew/2 > tx + 0.9 && entity.motionX < 0.1) entity.motionX = 90;\n                    break;\n                case 2:\n                    if(ey - eh/2 > ty + 0.9 && entity.motionY > -0.1) entity.motionY = 30;\n                    break;\n                case 3:\n                    if(ex + ew/2 < tx + 0.1 && entity.motionX < 0.1) entity.motionX = -90;\n                    break;\n            }\n        })\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/bouncepad.js?");

/***/ }),

/***/ "./client/blocks/brick.js":
/*!********************************!*\
  !*** ./client/blocks/brick.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Brick extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Brick\";\n    static description = \"A solid brick block\";\n    static id = 0;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/brick.js?");

/***/ }),

/***/ "./client/blocks/chain.js":
/*!********************************!*\
  !*** ./client/blocks/chain.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Chain extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Chain\";\n    static description = \"Non-solid decoration block\";\n    static id = 3;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/chain.js?");

/***/ }),

/***/ "./client/blocks/fireballshooter.js":
/*!******************************************!*\
  !*** ./client/blocks/fireballshooter.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EntityHandler = __webpack_require__(/*! ../entityhandler.js */ \"./client/entityhandler.js\");\n\nmodule.exports = class FireballShooter extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Fireball Shooter\";\n    static description = \"Shoots fireballs out of the front\";\n    static id = 25;\n    static rotatable = true;\n    \n    static tick(block) {\n        let x = 0;\n        let y = 0;\n        switch(block.rotation) {\n            case 0:\n                EntityHandler.spawnEntity(\"Fireball\", block.x + 0.5, block.y - 0.5, { motionY: -6 });\n                break;\n            case 1:\n                EntityHandler.spawnEntity(\"Fireball\", block.x + 1.5, block.y + 0.5, { motionX: 6 });\n                break;\n            case 2:\n                EntityHandler.spawnEntity(\"Fireball\", block.x + 0.5, block.y + 1.5, { motionY: 6 });\n                break;\n            case 3:\n                EntityHandler.spawnEntity(\"Fireball\", block.x - 0.5, block.y + 0.5, { motionX: -6 });\n                break;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/fireballshooter.js?");

/***/ }),

/***/ "./client/blocks/flag.js":
/*!*******************************!*\
  !*** ./client/blocks/flag.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Flag extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Flag\";\n    static description = \"Triggers the level win screen\";\n    static id = 2;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            entity.win();\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/flag.js?");

/***/ }),

/***/ "./client/blocks/flagblock.js":
/*!************************************!*\
  !*** ./client/blocks/flagblock.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Flag extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Flag\";\n    static description = \"Triggers the level win screen\";\n    static id = 19;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            entity.win();\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/flagblock.js?");

/***/ }),

/***/ "./client/blocks/forcefield.js":
/*!*************************************!*\
  !*** ./client/blocks/forcefield.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Forcefield extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Forcefield\";\n    static description = \"Pushes players in the direction it's facing\";\n    static id = 14;\n    static rotatable = true;\n\n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n\n        setTimeout(() => {\n            switch(collision.tile.rotation) {\n                case 0:\n                    entity.motionX += 1;\n                    break;\n                case 1:\n                    entity.motionY += 0.2;\n                    break;\n                case 2:\n                    entity.motionX -= 1;\n                    break;\n                case 3:\n                    entity.motionY -= 0.2;\n                    break;\n            }\n        })\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/forcefield.js?");

/***/ }),

/***/ "./client/blocks/grate.js":
/*!********************************!*\
  !*** ./client/blocks/grate.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Grate extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Grate\";\n    static description = \"Player can jump up through the block\";\n    static id = 9;\n\n    static onEntityHit(entity, collision) {\n        if(entity.motionY < 0 || entity.y > collision.tile.y) {\n            collision.colliding = false;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/grate.js?");

/***/ }),

/***/ "./client/blocks/gravityorb.js":
/*!*************************************!*\
  !*** ./client/blocks/gravityorb.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class JumpOrb extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Gravity Orb\";\n    static description = \"Flips gravity on use\";\n    static id = 16;\n\n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        \n        if(entity.type == \"player\") {\n            entity.canGravityJump = true;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/gravityorb.js?");

/***/ }),

/***/ "./client/blocks/icon-experimental.js":
/*!********************************************!*\
  !*** ./client/blocks/icon-experimental.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class JumpOrb extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"icon.experimental.name\";\n    static description = \"icon.experimental.desc\";\n    static id = 63;\n\n    static onEntityHit(a,b) {\n        b.colliding = false;\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/icon-experimental.js?");

/***/ }),

/***/ "./client/blocks/invisible.js":
/*!************************************!*\
  !*** ./client/blocks/invisible.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Invisible extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Invisible Block\";\n    static description = \"A transparent block with a small border\";\n    static id = 6;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/invisible.js?");

/***/ }),

/***/ "./client/blocks/jumporb.js":
/*!**********************************!*\
  !*** ./client/blocks/jumporb.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class JumpOrb extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Jump Orb\";\n    static description = \"Enables double-jump ability\";\n    static id = 8;\n\n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        \n        if(entity.type == \"player\") {\n            entity.canDoubleJump = true;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/jumporb.js?");

/***/ }),

/***/ "./client/blocks/lava.js":
/*!*******************************!*\
  !*** ./client/blocks/lava.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Lava extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Lava\";\n    static description = \"Basically dangerous water\";\n    static id = 12;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            if(Math.sqrt((entity.x - collision.tile.x - 0.5)**2 + (entity.y - collision.tile.y - 0.5)**2) < 0.8) {\n                entity.kill();\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/lava.js?");

/***/ }),

/***/ "./client/blocks/levetatingblock.js":
/*!******************************************!*\
  !*** ./client/blocks/levetatingblock.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class LevetatingBlock extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Levetating Block\";\n    static description = \"Gives the look of a levetating block\";\n    static id = 17;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/levetatingblock.js?");

/***/ }),

/***/ "./client/blocks/lock.js":
/*!*******************************!*\
  !*** ./client/blocks/lock.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Lock extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Lock block\";\n    static description = \"Unlocks only if the player is holding a key\";\n    static id = 24;\n\n    static onEntityHit(entity, collision) {\n        if(entity.type == \"player\") {\n            if(entity.holdingEntity?.type == \"key\") {\n                delete entity.holdingEntity;\n                entity.holdingEntity = null;\n\n                tilemap.setTile(collision.tile.x, collision.tile.y, -1);\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/lock.js?");

/***/ }),

/***/ "./client/blocks/metal.js":
/*!********************************!*\
  !*** ./client/blocks/metal.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Metal extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Metal Block\";\n    static description = \"A solid metal block\";\n    static id = 4;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/metal.js?");

/***/ }),

/***/ "./client/blocks/roundspike.js":
/*!*************************************!*\
  !*** ./client/blocks/roundspike.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class RoundSpike extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Round Spike\";\n    static description = \"Kills the player on touch of any side\";\n    static id = 10;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            if(Math.sqrt((entity.x - collision.tile.x - 0.5)**2 + (entity.y - collision.tile.y - 0.5)**2) < 0.8) {\n                entity.kill();\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/roundspike.js?");

/***/ }),

/***/ "./client/blocks/sludge.js":
/*!*********************************!*\
  !*** ./client/blocks/sludge.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Sludge extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Sludge\";\n    static description = \"Green version of lava, but more toxic (kills you from farther away)\";\n    static id = 18;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        entity.kill();\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/sludge.js?");

/***/ }),

/***/ "./client/blocks/spawnpoint.js":
/*!*************************************!*\
  !*** ./client/blocks/spawnpoint.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Spawnpoint extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Spawnpoint\";\n    static description = \"Sets the player's spawn point\";\n    static id = 11;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            entity.spawnX = collision.tile.x + 0.5;\n            entity.spawnY = collision.tile.y + 0.5;\n            entity.spawnInvertedGravity = entity.invertedGravity;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/spawnpoint.js?");

/***/ }),

/***/ "./client/blocks/spawnpointblock.js":
/*!******************************************!*\
  !*** ./client/blocks/spawnpointblock.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Spawnpoint extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Spawnpoint\";\n    static description = \"Sets the player's spawn point\";\n    static id = 20;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n        if(entity.type == \"player\") {\n            entity.spawnX = collision.tile.x + 0.5;\n            entity.spawnY = collision.tile.y + 0.5;\n            entity.spawnInvertedGravity = entity.invertedGravity;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/spawnpointblock.js?");

/***/ }),

/***/ "./client/blocks/spike.js":
/*!********************************!*\
  !*** ./client/blocks/spike.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Spike extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Spike\";\n    static description = \"Kills the player on touch on top\";\n    static id = 1;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        if(entity.type == \"player\") {\n            let hitBottom = false;\n            switch(collision.tile.rotation) {\n                case 0:\n                    hitBottom = entity.y > collision.tile.y + 1;\n                    break;\n                case 1:\n                    hitBottom = entity.x < collision.tile.x;\n                    break;\n                case 2:\n                    hitBottom = entity.y < collision.tile.y;\n                    break;\n                case 3:\n                    hitBottom = entity.x > collision.tile.x + 1;\n                    break;\n            }\n\n            if(hitBottom) {\n                collision.colliding = true;\n            } else {\n                collision.colliding = false;\n\n                if(Math.sqrt((entity.x - (collision.tile.x + 0.5))**2 + (entity.y - (collision.tile.y + 0.5))**2) < 0.75) {\n                    entity.kill();\n                }\n            }\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/spike.js?");

/***/ }),

/***/ "./client/blocks/technochain.js":
/*!**************************************!*\
  !*** ./client/blocks/technochain.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class TechnoChain extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Techno-Chain\";\n    static description = \"Non-solid decoration block\";\n    static id = 21;\n    static rotatable = true;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/technochain.js?");

/***/ }),

/***/ "./client/blocks/technometal.js":
/*!**************************************!*\
  !*** ./client/blocks/technometal.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class TechnoMetal extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Techno Metal Block\";\n    static description = \"A solid metal block\";\n    static id = 22;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/technometal.js?");

/***/ }),

/***/ "./client/blocks/water.js":
/*!********************************!*\
  !*** ./client/blocks/water.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Water extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Water\";\n    static description = \"Slows down player when inside, and allows player to swim\";\n    static id = 5;\n    \n    static onEntityHit(entity, collision) {\n        collision.colliding = false;\n\n        entity.timeScale = 0.5;\n        if(entity.type == \"player\") {\n            entity.canSwim = true;\n        }\n    }\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/water.js?");

/***/ }),

/***/ "./client/blocks/wood.js":
/*!*******************************!*\
  !*** ./client/blocks/wood.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = class Wood extends __webpack_require__(/*! ./block.js */ \"./client/blocks/block.js\") {\n    static displayname = \"Wood\";\n    static description = \"A solid wood block\";\n    static id = 15;\n}\n\n//# sourceURL=webpack://arlosmod/./client/blocks/wood.js?");

/***/ }),

/***/ "./client/blocks sync recursive ^\\.\\/.*\\.js$":
/*!******************************************!*\
  !*** ./client/blocks/ sync ^\.\/.*\.js$ ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./block.js\": \"./client/blocks/block.js\",\n\t\"./blue.js\": \"./client/blocks/blue.js\",\n\t\"./bouncepad.js\": \"./client/blocks/bouncepad.js\",\n\t\"./brick.js\": \"./client/blocks/brick.js\",\n\t\"./chain.js\": \"./client/blocks/chain.js\",\n\t\"./fireballshooter.js\": \"./client/blocks/fireballshooter.js\",\n\t\"./flag.js\": \"./client/blocks/flag.js\",\n\t\"./flagblock.js\": \"./client/blocks/flagblock.js\",\n\t\"./forcefield.js\": \"./client/blocks/forcefield.js\",\n\t\"./grate.js\": \"./client/blocks/grate.js\",\n\t\"./gravityorb.js\": \"./client/blocks/gravityorb.js\",\n\t\"./icon-experimental.js\": \"./client/blocks/icon-experimental.js\",\n\t\"./invisible.js\": \"./client/blocks/invisible.js\",\n\t\"./jumporb.js\": \"./client/blocks/jumporb.js\",\n\t\"./lava.js\": \"./client/blocks/lava.js\",\n\t\"./levetatingblock.js\": \"./client/blocks/levetatingblock.js\",\n\t\"./lock.js\": \"./client/blocks/lock.js\",\n\t\"./metal.js\": \"./client/blocks/metal.js\",\n\t\"./roundspike.js\": \"./client/blocks/roundspike.js\",\n\t\"./sludge.js\": \"./client/blocks/sludge.js\",\n\t\"./spawnpoint.js\": \"./client/blocks/spawnpoint.js\",\n\t\"./spawnpointblock.js\": \"./client/blocks/spawnpointblock.js\",\n\t\"./spike.js\": \"./client/blocks/spike.js\",\n\t\"./technochain.js\": \"./client/blocks/technochain.js\",\n\t\"./technometal.js\": \"./client/blocks/technometal.js\",\n\t\"./water.js\": \"./client/blocks/water.js\",\n\t\"./wood.js\": \"./client/blocks/wood.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./client/blocks sync recursive ^\\\\.\\\\/.*\\\\.js$\";\n\n//# sourceURL=webpack://arlosmod/./client/blocks/_sync_^\\.\\/.*\\.js$?");

/***/ }),

/***/ "./client/editor/editor.js":
/*!*********************************!*\
  !*** ./client/editor/editor.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("console.log(\"attach\");\nconst EditorUI = __webpack_require__(/*! ./editorui.js */ \"./client/editor/editorui.js\");\nconst Input = __webpack_require__(/*! ../input.js */ \"./client/input.js\");\nconst Renderer = __webpack_require__(/*! ./renderer.js */ \"./client/editor/renderer.js\");\nconst SelectedItem = __webpack_require__(/*! ../entities/selecteditem.js */ \"./client/entities/selecteditem.js\");\nconst Listener = __webpack_require__(/*! ../listeners.js */ \"./client/listeners.js\");\nconst EntityHandler = __webpack_require__(/*! ../entityhandler.js */ \"./client/entityhandler.js\");\nconst AssetLoader = __webpack_require__(/*! ../assetloader.js */ \"./client/assetloader.js\");\n\nfunction compressLevel(name, desc, blocks) {\n    blocks ??= tilemap.save();\n    \n    return {\n        name, desc, blocks\n    };\n}\n\nlet lastItemPos = [0,0];\nclass Editor {\n    static selectedItemEntity = null;\n    static drawing = false;\n    static holdingEntity = null;\n    static draggingDeathZone = false;\n    static testing = false;\n    static preview = null;\n    static tool = 0;\n\n    static panning = false;\n    static panStart = [0.0,0.0];\n    static viewportPosStart = [0.0,0.0];\n    \n    static setup() {\n        Listener.attach(this);\n\n        //Setup UIs\n        EditorUI.setup();\n\n        \n        this.selectedItemEntity = EntityHandler.spawnEntity(SelectedItem, 0, 0);\n        this.selectedItemEntity.texture = new Image();\n        {\n            EditorUI.addEventListener(\"*\", (type, ...args) => {\n                this.dispatchEvent(type, ...args);\n            });\n            EditorUI.addEventListener(\"start\", () => {\n                this.setTesting(true);\n                document.querySelector(\"canvas\").style.cursor = \"url('/assets/basicCursor.png'), auto\";\n            });\n            EditorUI.addEventListener(\"stop\", () => {\n                this.setTesting(false);\n                document.querySelector(\"canvas\").style.cursor = `url(/'assets/${this.tool == 0 ? \"brushCursor.png\" : \"basicCursor.png\"}'), auto`;\n            });\n            EditorUI.addEventListener(\"eraser\", () => {\n                this.selectedItemEntity.texture.src = AssetLoader.assets[\"menu/eraser\"].src;\n                this.selectedItemEntity.rotation = 0;\n            });\n            EditorUI.addEventListener(\"spawn\", () => {\n                this.holdingEntity = spawnflag;\n            });\n            EditorUI.addEventListener(\"save\", () => {\n                EditorUI.openPublishLevelScreen();\n            })\n            EditorUI.addEventListener(\"selectblock\", (name) => {\n                this.selectedItemEntity.rotation = EditorUI.rotation * (Math.PI/2);\n                this.selectedItemEntity.texture.src = getIcon(name);\n                \n                const selectedBlock = AssetLoader.blocks[name];\n                if(!selectedBlock || !selectedBlock.rotatable) this.selectedItemEntity.rotation = 0;\n            });\n            EditorUI.addEventListener(\"rotate\", (rotation) => {\n                this.selectedItemEntity.rotation = rotation * (Math.PI/2);\n    \n                const rotatedBlock = AssetLoader.blocks[EditorUI.selectedBlockName];\n                if(!rotatedBlock || !rotatedBlock.rotatable) this.selectedItemEntity.rotation = 0;\n            });\n            EditorUI.addEventListener(\"select\", () => {\n                this.tool = 1;\n                document.querySelector(\"canvas\").style.cursor = \"url('/assets/basicCursor.png'), auto\";\n            });\n            EditorUI.addEventListener(\"brush\", () => {\n                this.tool = 0;\n                document.querySelector(\"canvas\").style.cursor = \"url('/assets/brushCursor.png'), auto\";\n            });\n            \n            document.querySelector(\"canvas\").style.cursor = \"url('/assets/brushCursor.png'), auto\";\n    \n            EditorUI.addEventListener(\"click-save-locally\", (name, desc) => {\n                const save = compressLevel(name, desc);\n                this.dispatchEvent(\"save-locally\", save);\n            });\n            EditorUI.addEventListener(\"click-save-online\", (name, desc) => {\n                const save = compressLevel(name, desc);\n                this.dispatchEvent(\"save-online\", save);\n            });\n        }\n        //Zoom view in and out\n        document.body.addEventListener(\"wheel\", (e) => {\n            if(this.testing || EditorUI.inPopup) return;\n            \n            if(e.deltaY > 0) {\n                Renderer.viewport.zoom /= 1.1;\n            } else {\n                Renderer.viewport.zoom *= 1.1;\n            }\n        })\n\n        EditorUI.openCategory(0);\n        EditorUI.selectBlock(\"brick\");\n\n        Input.addEventListener(\"mousedown\", (button) => {\n            if(mouseOverUI) return;\n            if(!this.holdingEntity && this.tool == 0 && button == 0) {\n                this.drawing = true;\n            } else if(this.tool == 1 && button == 0) {\n                if(Math.abs(deathZone - Renderer.getWorldPos(0,Input.mouseY)[1]) < 0.2 / Renderer.viewport.zoom) this.draggingDeathZone = true;\n            }\n            if(button == 1) {\n                this.panning = true;\n                this.panStart = [Input.mouseX,Input.mouseY];\n                this.viewportPanStart = [Renderer.viewport.x,Renderer.viewport.y];\n            }\n        })\n        Input.addEventListener(\"mouseup\", (button) => {\n\n\n            if(button == 0) {\n                if(this.holdingEntity) {\n                    this.holdingEntity.x = Math.floor(this.holdingEntity.x) + 0.5;\n                    this.holdingEntity.y = Math.floor(this.holdingEntity.y) + 0.5;\n                    this.holdingEntity = null;\n                }\n                this.drawing = false;\n                this.draggingDeathZone = false;\n            }\n            if(button == 1) {\n                this.panning = false;\n            }\n        })\n        \n        EditorUI.addEventListener(\"start\", () => {\n            this.testing = true;\n        })\n    }\n    static draw() {\n        let selectedItemPos = Renderer.getWorldPos(Input.mouseX, Input.mouseY);\n        let dist = Math.sqrt((selectedItemPos[0] - lastItemPos[0])**2 + (selectedItemPos[1] - lastItemPos[1])**2);\n\n        this.selectedItemEntity.hidden = (this.holdingEntity) || (this.testing) || (EditorUI.inPopup);\n\n        if(!this.testing && !EditorUI.inPopup) {\n            if(this.panning) {\n                let [x, y] = Renderer.getWorldPos(...this.panStart);\n                let [x2, y2] = Renderer.getWorldPos(Input.mouseX, Input.mouseY);\n                x -= x2;\n                y -= y2;\n                \n                \n\n                x += this.viewportPanStart[0];\n                y += this.viewportPanStart[1];\n\n                Renderer.viewport.x = x; \n                Renderer.viewport.y = y; \n            } else {\n                this.selectedItemEntity.x += ((Math.floor(selectedItemPos[0]) + 0.5) - this.selectedItemEntity.x) / 4;\n                this.selectedItemEntity.y += ((Math.floor(selectedItemPos[1]) + 0.5) - this.selectedItemEntity.y) / 4;\n                this.selectedItemEntity.hidden ||= this.tool != 0;\n\n                if(this.holdingEntity) {\n                    this.holdingEntity.x = this.selectedItemEntity.x;\n                    this.holdingEntity.y = this.selectedItemEntity.y;\n                }\n\n            }\n\n            if(Input.keysPressed.includes(\"w\")) Renderer.viewport.y -= 0.5/Renderer.viewport.zoom;\n            if(Input.keysPressed.includes(\"s\")) Renderer.viewport.y += 0.5/Renderer.viewport.zoom;\n            if(Input.keysPressed.includes(\"a\")) Renderer.viewport.x -= 0.5/Renderer.viewport.zoom;\n            if(Input.keysPressed.includes(\"d\")) Renderer.viewport.x += 0.5/Renderer.viewport.zoom;\n            \n\n\n            if(this.drawing) {\n                let dx = lastItemPos[0] - selectedItemPos[0];\n                let dy = lastItemPos[1] - selectedItemPos[1];\n                \n                let rotation = EditorUI.rotation;\n                const block = AssetLoader.blocks[EditorUI.selectedBlockName];\n                const rotatable = block?.rotatable ?? false;\n\n                for(let i = 0; i <= 1; i += 1/dist) {\n                    let x = Math.lerp(0, dx, i) + selectedItemPos[0];\n                    let y = Math.lerp(0, dy, i) + selectedItemPos[1];\n\n                    tilemap.setTile(x, y, EditorUI.selectedBlock, rotatable ? rotation : 0);\n                }\n            }\n            if(this.draggingDeathZone) {\n                deathZone = Renderer.getWorldPos(0,Input.mouseY)[1];\n            }\n\n            lastItemPos = selectedItemPos;\n        }\n    }\n\n    static setTesting(testing) {\n        this.testing = testing;\n        const el1 = document.querySelector(\"#editor-selected-block\");\n        const el2 = document.querySelector(\"#selection-hint\");\n        const el3 = document.querySelector(\"#editor-bar-bottom\");\n        const el4 = document.querySelector(\"#editor-menu-items\");\n        const el5 = document.querySelector(\"#editor-selection-tools\");\n        const el6 = document.querySelector(\"#editor-playtesting-menu\");\n\n        if(testing) {\n            this.preview = Renderer.viewport.properties;\n            el1.classList.add(\"hidden\");\n            el2.classList.add(\"hidden\");\n            el3.classList.add(\"hidden\");\n            el4.classList.add(\"hidden\");\n            el5.classList.add(\"hidden\");\n            el6.classList.remove(\"hidden\");\n        } else {\n            Renderer.viewport.properties = this.preview;\n            el1.classList.remove(\"hidden\");\n            el2.classList.remove(\"hidden\");\n            el3.classList.remove(\"hidden\");\n            el4.classList.remove(\"hidden\");\n            el5.classList.remove(\"hidden\");\n            el6.classList.add(\"hidden\");\n        }\n        \n        this.dispatchEvent(testing ? \"start\" : \"stop\");\n    }\n\n    static submissionError(body) {\n        EditorUI.submissionError(body);\n    }\n    static submissionSuccess(body) {\n        EditorUI.submissionSuccess(body);\n    }\n}\n\nmodule.exports = Editor;\n\n//# sourceURL=webpack://arlosmod/./client/editor/editor.js?");

/***/ }),

/***/ "./client/editor/editorui.js":
/*!***********************************!*\
  !*** ./client/editor/editorui.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("console.log(\"attach\");\n\nconst Listener = __webpack_require__(/*! ../listeners.js */ \"./client/listeners.js\");\nconst Input = __webpack_require__(/*! ../input.js */ \"./client/input.js\");\nconst AssetLoader = __webpack_require__(/*! ../assetloader.js */ \"./client/assetloader.js\");\n\nclass EditorUI {\n    static blockCategories = [\n        {\n            \"icon\": \"brick\",\n            \"name\": \"Solid blocks\",\n            \"blocks\": [\n                \"brick\",\n                \"metal\",\n                \"invisible\",\n                \"wood\",\n                \"technometal\",\n                \"blue\"\n            ]\n        },\n        {\n            \"icon\": \"spike\",\n            \"name\": \"Hazards\",\n            \"blocks\": [\n                \"spike\",\n                \"roundspike\",\n                \"lava\",\n                \"sludge\",\n                \"fireballshooter\"\n            ]\n        },\n        {\n            \"icon\": \"chain\",\n            \"name\": \"Decoration\",\n            \"blocks\": [\n                \"chain\",\n                \"technochain\",\n                \"water\",\n                \"grate\",\n                \"levetatingblock\"\n            ]\n        },\n        {\n            \"icon\": \"flag\",\n            \"name\": \"Special blocks\",\n            \"blocks\": [\n                \"flag\",\n                \"flagblock\",\n                \"spawnpoint\",\n                \"spawnpointblock\",\n                \"bouncepad\",\n                \"jumporb\",\n                \"forcefield\",\n                \"gravityorb\",\n            ]\n        },\n        {\n            \"icon\": \"menu/experimental\",\n            \"name\": \"Experimental (Blocks Still in Development)\",\n            \"blocks\": [\n                \"lock\"\n            ]\n        }\n    ]\n    static selectedCategory = 0;\n    static selectedBlock = 0;\n    static selectedBlockName = \"\";\n    static rotation = 0;\n\n    static inPopup = false;\n\n    static openCategory(index) {\n        let category = this.blockCategories[index];\n        if(!category) return;\n\n        this.selectedCategory = index;\n\n        //Hide all block categories except selected one\n        const blockContainers = document.querySelector(\"#editor-blocks\").children;\n        [...blockContainers].forEach((child) => {\n            if(child.getAttribute(\"id\") == \"category-\"+index+\"-blocks\") {\n                child.style.visibility = \"visible\";\n            } else {\n                child.style.visibility = \"hidden\";\n            }\n        })\n\n        this.dispatchEvent(\"opencategory\",this.selectedCategory);\n    }\n    \n    static selectBlock(name) {\n        let block = AssetLoader.blocks[name];\n        if(!block) return;\n\n        const clickedElement = document.querySelector(`#category-${this.selectedCategory}-block-${name}`);\n        \n        document.querySelector(\"#editor-selected-block > div > img\").src = clickedElement.querySelector(\"img\").src;\n\n        this.selectedBlock = block.id;\n        this.selectedBlockName = name;\n        this.dispatchEvent(\"selectblock\",name,block.id);\n    }\n\n    static showHint(text) {\n        const hintElement = document.querySelector(\"#selection-hint\");\n        hintElement.hidden = false;\n        hintElement.textContent = text;\n    }\n\n    static hideHint() {\n        const hintElement = document.querySelector(\"#selection-hint\");\n        hintElement.hidden = true;\n    }\n\n    static setup() {\n        Listener.attach(this);\n\n        this.loadCategories();\n\n        //Setup top menu buttons\n        document.querySelector(\"#eraser\").addEventListener(\"click\", () => {\n            this.selectedBlock = -1;\n            this.selectedBlockName = \"\";\n            this.dispatchEvent(\"eraser\");\n        })\n        document.querySelector(\"#spawn\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"spawn\");\n        })\n        \n        document.querySelector(\"#save\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"save\");\n        })\n\n        document.querySelector(\"#start\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"start\");\n        })\n\n        document.querySelector(\"#stop\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"stop\");\n        })\n\n        document.querySelector(\"#brush\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"brush\");\n        })\n\n        document.querySelector(\"#select\").addEventListener(\"click\", () => {\n            this.dispatchEvent(\"select\");\n        })\n\n        Input.addEventListener(\"keydown\", (key) => {\n            if(key == \"r\") {\n                if(Input.keysPressed.includes(\"shift\")) this.rotation = (this.rotation - 1).mod(4);\n                else this.rotation = (this.rotation + 1).mod(4);\n\n                this.dispatchEvent(\"rotate\", this.rotation);\n            }\n        })\n    }\n\n    static loadCategories() {\n        for(let i in this.blockCategories) {\n            const category = this.blockCategories[i];\n\n            const { icon, name, blocks } = category;\n\n            //Setup ui elements\n            const categoryElement = document.createElement(\"div\");\n            const imageIcon = document.createElement(\"img\");\n\n            categoryElement.classList.add(\"menu-icon\");\n            categoryElement.setAttribute(\"id\",\"category-\" + i);\n            \n            const id = AssetLoader.getIdForBlock(icon);\n            imageIcon.src = id != null ? tilemap.getTileImage(id) : `/assets/${icon}.png`;\n            imageIcon.draggable = false;\n\n            categoryElement.appendChild(imageIcon);\n            categoryElement.addEventListener(\"click\", (e) => {\n                this.openCategory(i);\n            })\n            categoryElement.addEventListener(\"mouseover\", (e) => {\n                this.showHint(`${name}`);\n            })\n            categoryElement.addEventListener(\"mouseout\", (e) => {\n                this.hideHint();\n            })\n\n            const blockGroupElement = document.createElement(\"div\");\n            blockGroupElement.setAttribute(\"id\",\"category-\"+i+\"-blocks\");\n\n            //Overlap elements procedurally because css is stupid\n            if(i != 0) blockGroupElement.style.marginTop = `-19px`\n            \n\n            for(let block of blocks) {\n\n                //Setup block button\n                const blockElement = document.createElement(\"div\");\n                const blockImageIcon = document.createElement(\"img\");\n\n                blockElement.classList.add(\"menu-icon\");\n                blockElement.setAttribute(\"id\",\"category-\"+i+\"-block-\"+block);\n                blockImageIcon.src = tilemap.getTileImage(AssetLoader.getIdForBlock(block));\n                blockImageIcon.draggable = false;\n                \n                blockElement.appendChild(blockImageIcon);\n                blockGroupElement.appendChild(blockElement);\n\n                blockElement.addEventListener(\"click\", (e) => {\n                    this.selectBlock(block);\n                })\n\n                const blockOption = AssetLoader.blocks[block];\n                blockElement.addEventListener(\"mouseover\", (e) => {\n                    this.showHint(`${blockOption.displayname} | ${blockOption.description}`);\n                })\n                blockElement.addEventListener(\"mouseout\", (e) => {\n                    this.hideHint();\n                })\n            }\n\n            document.querySelector(\"#editor-block-groups\").appendChild(categoryElement);\n            document.querySelector(\"#editor-blocks\").appendChild(blockGroupElement);\n        }\n    }\n\n    static openPopup(element) {\n        element.classList.remove(\"hidden\");\n        this.inPopup = true;\n\n        element.querySelector(\".close-popup\").addEventListener(\"click\", () => {\n            this.inPopup = false;\n            element.classList.add(\"hidden\");\n        });\n\n        element.querySelector(\"form\")?.addEventListener(\"submit\", (e) => {\n            e.preventDefault();\n        });\n        let options = element.querySelectorAll(\".popup-options > input\");\n\n        return options\n    }\n\n    static openPublishLevelScreen() {\n        if(this.inPopup) return;\n        \n        const element = document.querySelector(\"#save-popup\");\n        const options = this.openPopup(element);\n\n        options[0].onclick = () => {\n            const name = element.querySelector(\".level-name\").value;\n            const desc = element.querySelector(\".level-desc\").value;\n            \n            options[0].disabled = true;\n            setTimeout(() => {\n                this.dispatchEvent(\"click-save-online\", name, desc);\n                options[0].disabled = false;\n            }, 25)\n        }\n        options[1].onclick = () => {\n            const name = element.querySelector(\".level-name\").value;\n            const desc = element.querySelector(\".level-desc\").value;\n            \n            options[1].disabled = true;\n            setTimeout(() => {\n                this.dispatchEvent(\"click-save-locally\", name, desc);\n                options[1].disabled = false;\n            }, 25)\n        }\n    }\n\n    static submissionSuccess(body) {\n        let el = document.querySelector(\"#submission-message\");\n        el.textContent = \"Level successfully submitted\";\n        el.setAttribute(\"class\",\"success\");\n        \n        const element = document.querySelector(\"#save-online-success-popup\");\n        const options = this.openPopup(element);\n\n        options[0].onclick = () => {\n            window.location = `/browse?level=${body.id}`;\n        }\n        options[1].onclick = () => {\n            element.querySelector(\".close-popup\").click();\n        }\n\n        element.querySelector(\".level-id\").textContent = body.id;\n    }\n    static submissionError(body) {\n        let el = document.querySelector(\"#submission-message\");\n        el.textContent = body;\n        el.setAttribute(\"class\",\"error\");\n    }\n}\n\nmodule.exports = EditorUI;\n\n//# sourceURL=webpack://arlosmod/./client/editor/editorui.js?");

/***/ }),

/***/ "./client/editor/main.js":
/*!*******************************!*\
  !*** ./client/editor/main.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconsole.log(\"attach\");\n\nwith(window) {\n    //Import modules\n    const EntityHandler = __webpack_require__(/*! ../entityhandler.js */ \"./client/entityhandler.js\");\n    const AssetLoader = __webpack_require__(/*! ../assetloader.js */ \"./client/assetloader.js\");\n\n    const Tilemap = __webpack_require__(/*! ../tilemap.js */ \"./client/tilemap.js\");\n    const Input = __webpack_require__(/*! ../input.js */ \"./client/input.js\");\n    const ServerInterface = __webpack_require__(/*! ../serverinterface.js */ \"./client/serverinterface.js\");\n\n    const Viewport = __webpack_require__(/*! ../viewport.js */ \"./client/viewport.js\");\n    const Renderer = __webpack_require__(/*! ./renderer.js */ \"./client/editor/renderer.js\");\n\n    const Editor = __webpack_require__(/*! ./editor.js */ \"./client/editor/editor.js\");\n    \n    //Modify prototypes\n    {\n        Math.lerp = function(v1, v2, t) {\n            return v1 + (v2 - v1) * t;\n        }\n        Number.prototype.mod = function (n) {\n            return ((this % n) + n) % n;\n        };\n    }\n    \n    player = null;\n    spawnflag = null;\n    selectedItem = null;\n    mouseOverUI = false;\n    assets = {};\n\n    //Only tick these objects if simulating is true\n    gameObjectSimulators = [\"fireball\"];\n    simulating = false;\n\n    deathZone = 130;\n\n\n    getIcon = function(id) {\n        //Convert string id to numerical id\n        if(typeof id == \"string\") id = AssetLoader.blocks[id]?.id ?? 0;\n\n        return tilemap.getTileImage(id);\n    }\n\n    async function start() {\n        EntityHandler.loadDefault();\n        await AssetLoader.loadDefault();\n        \n        Renderer.attach(document.querySelector(\"canvas\"));\n        Input.listen(document.body);\n        \n        //Load tilemap\n        tilemap = new Tilemap(256,256);\n        const [ texture, uvs ] = await tilemap.setTexture({\n            src: \"/assets/blocks.png\",\n        });\n\n        //Setup scene\n        spawnflag = EntityHandler.spawnEntity(\"SpawnFlag\", Math.floor(tilemap.width / 2) + 0.5, Math.floor(tilemap.height - 20) + 0.5);\n        player = EntityHandler.spawnEntity(\"Player\", Math.floor(tilemap.width / 2) + 0.5, Math.floor(tilemap.height / 2) + 0.5);\n        Renderer.viewport.x = spawnflag.x;\n        Renderer.viewport.y = spawnflag.y;\n\n        deathZone = spawnflag.y + 10;\n\n        Editor.setup();\n        \n        player.addEventListener(\"win\", () => {\n            simulating = false;\n            Editor.setTesting(false);\n        })\n        Editor.addEventListener(\"start\", () => {\n            simulating = true;\n            player.static = false;\n            player.hidden = false;\n\n            player.x = spawnflag.x;\n            player.y = spawnflag.y;\n            player.invertedGravity = false;\n            player.spawnX = spawnflag.x;\n            player.spawnY = spawnflag.y;\n            player.spawnInvetedGravity = false;\n            \n            player.motionX = 0;\n            player.motionY = 0;\n        })\n        Editor.addEventListener(\"stop\", () => {\n            simulating = false;\n            player.static = true;\n            player.hidden = true;\n\n            //Kill all game entities\n            EntityHandler.entities.forEach((el, i) => {\n                if(gameObjectSimulators.includes(el.type)) {\n                    EntityHandler.removeEntity(el.id);\n                }\n            })\n        })\n\n        document.querySelector(\"#overlay\").addEventListener(\"mouseover\", () => {\n            mouseOverUI = true;\n        })\n        document.querySelector(\"#overlay\").addEventListener(\"mouseout\", () => {\n            mouseOverUI = false;\n        })\n\n        Editor.addEventListener(\"save-online\", async (data) => {\n            console.log(\"publish\",data);\n            const { status, body } = await ServerInterface.publishLevel(data);\n\n            if(status == 500) Editor.submissionError(body);\n                         else Editor.submissionSuccess(body);\n        })\n\n\n        let t0 = 0;\n        //Called whenever a frame is drawn\n        Renderer.addEventListener(\"draw\", (t1) => {\n            const dt = t1 - t0;\n            t0 = t1;\n\n            Renderer.drawTilemap(tilemap);\n            Editor.draw(t1);\n\n            //Draw all entities\n            EntityHandler.entities.forEach((entity, i) => {\n                Renderer.drawEntity(entity);\n            });\n\n            Renderer.drawDeathZone(deathZone);\n        })\n\n        //Automatically resize canvas on window resize\n        window.addEventListener(\"resize\", (e) => {\n            Renderer.resizeCanvas();\n        })\n\n        const tickableBlocks = [];\n        \n        //Tick blocks in view\n        setInterval(() => {\n            if(!simulating) return;\n            for(let x = Renderer.viewport.left; x < Renderer.viewport.right; x++) {\n                for(let y = Renderer.viewport.top; y < Renderer.viewport.bottom; y++) {\n                    const block = tilemap.blocks[x + y * tilemap.width];\n                    if(!block || block[0] == -1) continue;\n\n                    const blockobj = AssetLoader.blocks[AssetLoader.getNameForBlock(block[0])];\n                    if(!blockobj) continue;\n\n                    blockobj.tick?.(tilemap.getTile(x,y));\n                }\n            }\n        },1000);\n    }\n\n    //Called 100 times a second\n    function fixedUpdate() {\n        if(Editor.testing) {\n            Renderer.viewport.x += (player.x - Renderer.viewport.x) / 10;\n            Renderer.viewport.y += (player.y - Renderer.viewport.y) / 10;\n            Renderer.viewport.zoom += (2 - Renderer.viewport.zoom) / 50;\n\n            //Move player by directional keys\n            const moveX = Input.keysPressed.includes(\"d\") - Input.keysPressed.includes(\"a\");\n            player.move(moveX, Input.keysPressed.includes(\" \"));\n        }\n\n        //Tick all entities\n        EntityHandler.entities.forEach((entity) => {\n            const isGameObject = !entity.simulateInEditor;\n            if(isGameObject && !simulating) return;\n            entity.update(tilemap);\n        })\n    }\n\n    //pyramid of D O O M\n    start().then(() => {\n        setInterval(() => {\n            fixedUpdate()\n        },1000/100) //Game speed\n    });\n}\n\n//# sourceURL=webpack://arlosmod/./client/editor/main.js?");

/***/ }),

/***/ "./client/editor/renderer.js":
/*!***********************************!*\
  !*** ./client/editor/renderer.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconsole.log(\"attach\");\nconst Viewport = __webpack_require__(/*! ../viewport.js */ \"./client/viewport.js\");\nconst Listener = __webpack_require__(/*! ../listeners.js */ \"./client/listeners.js\");\nconst AssetLoader = __webpack_require__(/*! ../assetloader.js */ \"./client/assetloader.js\")\n\nclass Renderer {\n    static canvas = null;\n    static ctx = null;\n    static viewport = new Viewport(128, 128, 1, 16);\n    static assets = {};\n\n    static attach(canvasElement) {\n        this.canvas = canvasElement;\n        this.ctx = canvasElement.getContext(\"2d\");\n\n        //Resize canvas to fit screen\n        this.resizeCanvas();\n\n        //Apply a listener to this object\n        Listener.attach(this);\n\n        //Start draw loop\n        this.draw();\n    }\n\n    static resizeCanvas() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n    }\n\n    static draw(t) {\n        this.ctx.beginPath();\n        this.viewport.left = Math.floor(this.getWorldPos(0, 0)[0]);\n        this.viewport.right = Math.ceil(this.getWorldPos(window.innerWidth, 0)[0]);\n        this.viewport.top = Math.floor(this.getWorldPos(0, 0)[1]);\n        this.viewport.bottom = Math.ceil(this.getWorldPos(0, window.innerHeight)[1]);\n\n        //Clear screen\n        this.ctx.fillStyle = \"#333333\";\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n        //Fire drawing event for drawing tilemaps and entities\n        this.dispatchEvent(\"draw\", t);\n\n        //Continue draw loop\n        requestAnimationFrame(a=>this.draw(a));\n    }\n\n    //Draws specific entity based on entity.type\n    static drawEntity(entity) {\n        if(entity.hidden) return;\n\n\n        switch(entity.type) {\n            case \"player\":\n                this.drawPlayer(entity);\n                break;\n            case \"selecteditem\":\n                this.drawSelectedItem(entity);\n                break;\n            case \"spawnflag\":\n                this.drawSpawnFlag(entity);\n                break;\n            case \"entitybasic\":\n                this.drawEntityBasic(entity);\n                break;\n            case \"fireball\":\n                this.drawFireball(entity);\n                break;\n        }\n\n    }\n\n    //Player is a red box\n    static drawPlayer(player) {\n\n        this.ctx.fillStyle = \"#ff0000\";\n        this.drawRect(player.x, player.y, player.width, player.height, player.rotation);\n\n    }\n\n    //Basic entities are yellow boxes\n    static drawEntityBasic(entity) {\n        this.ctx.fillStyle = \"#ffff00\";\n        this.drawRect(entity.x, entity.y, entity.width, entity.height, entity.rotation);\n    }\n\n    static drawFireball(entity) {\n        this.ctx.fillStyle = \"#880000\";\n        this.drawRect(entity.x, entity.y, entity.width, entity.height, entity.rotation);\n    }\n\n    static drawSelectedItem(item) {\n        this.ctx.globalAlpha = 0.5;\n        this.drawImage(item.texture, item.x, item.y, 1, 1, item.rotation);\n        this.ctx.globalAlpha = 1.0;\n    }\n\n    static drawSpawnFlag(flag) {\n        this.drawImage(AssetLoader.assets[\"menu/spawn\"], flag.x, flag.y, 1, 1, flag.rotation);\n    }\n\n    static drawDeathZone(height) {\n        let { left, right, bottom, top } = this.viewport;\n        \n        if(height > bottom) return;\n        this.ctx.fillStyle = \"#ff8800\";\n        this.drawRect((left + right) / 2, (bottom + height) / 2, right - left, bottom - height);\n    }\n\n    //Draws a rectangle in the viewport respective to panning and zoom\n    static drawRect(x, y, w = 1, h = 1, r = 0) {\n        w *= this.viewport.scale * this.viewport.zoom;\n        h *= this.viewport.scale * this.viewport.zoom;\n\n        this.ctx.setTransform(1, 0, 0, 1, ...this.getScreenPos(x, y));\n        this.ctx.rotate(r);\n        this.ctx.fillRect(\n            w/-2, h/-2,\n            w,\n            h\n        )\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    //Draws a rectangle in the viewport respective to panning and zoom\n    static drawImage(image, x, y, w = 1, h = 1, r = 0) {\n        w *= this.viewport.scale * this.viewport.zoom;\n        h *= this.viewport.scale * this.viewport.zoom;\n\n        this.ctx.setTransform(1, 0, 0, 1, ...this.getScreenPos(x, y));\n        this.ctx.rotate(r);\n\n        this.ctx.drawImage(\n            image,\n            w/-2, h/-2,\n            w,\n            h\n        )\n        \n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    //Converts world space to screen space\n    static getScreenPos(x, y) {\n        x -= this.viewport.x;\n        y -= this.viewport.y;\n\n        x *= this.viewport.scale * this.viewport.zoom;\n        y *= this.viewport.scale * this.viewport.zoom;\n        \n        x += this.canvas.width / 2;\n        y += this.canvas.height / 2;\n\n        return [x,y];\n    }\n\n    //Converts screen space to world space\n    static getWorldPos(x, y) {\n        \n        x -= this.canvas.width / 2;\n        y -= this.canvas.height / 2;\n\n        x /= this.viewport.scale * this.viewport.zoom;\n        y /= this.viewport.scale * this.viewport.zoom;\n\n        x += this.viewport.x;\n        y += this.viewport.y;\n\n        return [x,y];\n    }\n\n    static drawTilemap(tilemap) {\n        //Extract variables\n        const { width, height } = this.canvas;\n        const { _x, _y, zoom } = this.viewport;\n        \n        //Use point sampling instead of billinear sampling\n        this.ctx.imageSmoothingEnabled = false;\n        \n        //Draws part of the tilemap's image onto the rendering canvas' screen\n        this.ctx.drawImage(\n            tilemap.canvas,\n            _x - width / 2 / zoom,\n            _y - height / 2 / zoom,\n            width / zoom,\n            height / zoom,\n            0, 0, width, height\n        );\n    }\n}\n\nmodule.exports = Renderer;\n\n//# sourceURL=webpack://arlosmod/./client/editor/renderer.js?");

/***/ }),

/***/ "./client/entities/bouncyball.js":
/*!***************************************!*\
  !*** ./client/entities/bouncyball.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\n\nclass BouncyBall extends Entity {\n    constructor() {\n        super(...arguments);\n        \n        this.useGravity = true;\n        this.static = false;\n        this.bounciness = 1;\n        this.drag = 0.99;\n        \n        this.killable = true;\n        this.killAtSessionEnd = true;\n    }\n\n    update(tilemaps) {\n        this.updatePhysics(tilemaps);\n    }\n}\n\nmodule.exports = BouncyBall;\n\n//# sourceURL=webpack://arlosmod/./client/entities/bouncyball.js?");

/***/ }),

/***/ "./client/entities/entity.js":
/*!***********************************!*\
  !*** ./client/entities/entity.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const AssetLoader = __webpack_require__(/*! ../assetloader.js */ \"./client/assetloader.js\");\n\nclass PointCollider {\n    constructor(x,y) {\n        this.offsetx = x;\n        this.offsety = y;\n        this.x = x;\n        this.y = y;\n    }\n    //Check if new position collides with the tilemap\n    update(entity, tilemap) {\n        this.x = entity.x + this.offsetx;\n        this.y = entity.y + this.offsety;\n\n        const tile = tilemap.colliding(this.x, this.y);\n        return tile;\n    }\n}\n\nclass Entity {\n    static gravity = -0.5;\n\n    constructor(x,y) {\n        this.type = \"entitybasic\";\n\n        //Entity position\n        this.x = x ?? 0;\n        this.y = y ?? 0;\n        this.spawnX = this.x;\n        this.spawnY = this.y;\n        \n        //Is the rigidbody affected by motion?\n        this.static = true;\n\n        //Is the rigidbody affected by gravity?\n        this.useGravity = true;\n\n        //Does the entity tick in the editor or only in-game?\n        this.tickInEditor = false;\n\n        //Kill at end of playtesting?\n        this.killAtSessionEnd = false;\n\n        //Entity motion\n        this.motionX = 0;\n        this.motionY = 0;\n\n        //X motion is multiplied by this value every tick (air resistance / friction)\n        this.drag = 0.85;\n\n        //Rigidbody size\n        this.width = 0.75;\n        this.height = 0.75;\n        this.colliderMargin = 0.00001;\n\n        //Other fun attributes\n        this.minMoveDistance = 0.1;\n        this.bounciness = 0;\n        this.timeScale = 1;\n        this.killable = false;\n\n        //Graphical attributes\n        this.hidden = false;\n        this.rotation = 0;\n\n        this.createCollider();\n    }\n\n    createCollider() {\n        /*\n            Collision points\n\n                0 ----- 1\n                |       |\n                |       |\n                2 ----- 3\n\n        */\n\n        //Default point colliders (IMPORTANT: CHANGE WHEN ADJUSTING SIZE)\n        this.pointColliders = [\n            new PointCollider(this.width / -2, this.height / -2),\n            new PointCollider(this.width /  2, this.height / -2),\n            new PointCollider(this.width / -2, this.height /  2),\n            new PointCollider(this.width /  2, this.height /  2)\n        ];\n    }\n\n    update(tilemaps) {\n        //Move object\n        this.updatePhysics(tilemaps);\n    }\n\n    updatePhysics(tilemap) {\n        if(this.static) return;\n        this.canSwim = false;\n        \n        //Entity falls at 0.5 blocks/s^2\n        if(this.useGravity) {\n            this.motionY -= Entity.gravity * this.timeScale;\n            this.motionX *= this.drag;\n            this.motionY *= 1 - (0.01 * this.timeScale);\n        } else {\n            this.motionX *= this.drag;\n            this.motionY *= this.drag;\n        }\n        this.airTime += 0.01;\n\n        //Limit move distance\n        if(Math.abs(this.motionX) < this.minMoveDistance) this.motionX = 0;\n        if(Math.abs(this.motionY) < this.minMoveDistance) this.motionY = 0;\n\n        //Check collisions for x axis\n        this.x += this.motionX * 0.01 * this.timeScale;\n        {\n            //Get all colliding points\n            const collisions = this.colliding(tilemap);\n            let left = false;\n            let right = false;\n\n            collisions.forEach((collision) => {\n                if(collision.block && collision.colliding) collision.block?.onEntityHit(this, collision);\n\n                //Find whether the collision is on the left or the right\n                if(collision.collider.offsetx < 0) left ||= collision.colliding;\n                else right ||= collision.colliding;\n                \n            })\n\n            //Resolve collision\n            if(left)\n                this.x = Math.ceil(this.x) - (1 - this.width/2) + this.colliderMargin;\n            if(right)\n                this.x = Math.floor(this.x) + (1 - this.width/2) - this.colliderMargin;\n\n            //If trapped in block then kill entity\n            if(left && right && this.killable) this.kill();\n\n            //Bounce back\n            if(left || right) this.motionX *= -this.bounciness;\n        }\n        \n\n        // Check collisions for y axis\n        this.y += this.motionY * 0.01 * this.timeScale;\n        {\n            //Get all colliding points\n            const collisions = this.colliding(tilemap);\n            let up = false;\n            let down = false;\n\n            collisions.forEach((collision) => {\n\n                //Dispatch hit event\n                if(collision.block && collision.colliding) collision.block?.onEntityHit(this, collision);\n\n                //Find whether the collision is on the left or the right\n                if(collision.collider.offsety < 0) up ||= collision.colliding;\n                else down ||= collision.colliding;\n            });\n\n            //Resolve collision\n            if(up) {\n                this.y = Math.ceil(this.y) - (1 - this.height/2) + this.colliderMargin;\n                if(Entity.gravity > 0) this.airTime = 0;\n            }\n            \n            if(down) {\n                this.y = Math.floor(this.y) + (1 - this.height/2) - this.colliderMargin;\n                if(Entity.gravity < 0) this.airTime = 0;\n            }\n\n            //If trapped in block then kill entity\n            if(up && down && this.killable) this.kill();\n\n            //Bounce back\n            if(up || down) this.motionY *= -this.bounciness;\n        }\n\n        if(this.y > deathZone + 1 && this.killable) this.kill();\n    }\n\n    kill() {\n        this.x = this.spawnX;\n        this.y = this.spawnY;\n        this.motionX = 0;\n        this.motionY = 0;\n    }\n\n    colliding(tilemap) {\n        let collisions = [];\n\n        //Get all colliding points of my point colliders\n        for(let collider of this.pointColliders) {\n            const [ colliding, block ] = collider.update(this, tilemap);\n\n            //Get behavior instance (contains onEntityHit)\n            const blockReference = AssetLoader.blocks[AssetLoader.getNameForBlock(block.id)];\n            collisions.push({ colliding, block: blockReference, tile: block, collider });\n        }\n        return collisions;\n    }\n}\n\nmodule.exports = Entity;\n\n//# sourceURL=webpack://arlosmod/./client/entities/entity.js?");

/***/ }),

/***/ "./client/entities/fireball.js":
/*!*************************************!*\
  !*** ./client/entities/fireball.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EntityHandler = __webpack_require__(/*! ../entityhandler.js */ \"./client/entityhandler.js\");\nconst Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\n\nclass Fireball extends Entity {\n    constructor() {\n        super(...arguments);\n        \n        this.type = \"fireball\";\n        this.useGravity = false;\n        this.static = false;\n        this.drag = 1;\n        \n        this.killable = true;\n        this.killAtSessionEnd = true;\n\n        this.life = 1000;\n    }\n\n    update(tilemaps) {\n        this.updatePhysics(tilemaps);\n\n        if(this.motionX == 0 && this.motionY == 0) {\n            EntityHandler.removeEntity(this.id);\n        }\n\n        if(this.life-- < 0) EntityHandler.removeEntity(this.id);\n\n        if(Math.sqrt((this.x - player.x) ** 2 + (this.y - player.y)**2) < 1) {\n            player.kill();\n            EntityHandler.removeEntity(this.id);\n        }\n    }\n}\n\nmodule.exports = Fireball;\n\n//# sourceURL=webpack://arlosmod/./client/entities/fireball.js?");

/***/ }),

/***/ "./client/entities/key.js":
/*!********************************!*\
  !*** ./client/entities/key.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\n\nclass Key extends Entity {\n    constructor() {\n        super(...arguments);\n        \n        this.type = \"item\";\n        this.texture = \"key\";\n        this.useGravity = false;\n        this.static = true;\n    }\n}\n\nmodule.exports = Key;\n\n//# sourceURL=webpack://arlosmod/./client/entities/key.js?");

/***/ }),

/***/ "./client/entities/player.js":
/*!***********************************!*\
  !*** ./client/entities/player.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\nconst Listener = __webpack_require__(/*! ../listeners.js */ \"./client/listeners.js\");\n\nclass Player extends Entity {\n    constructor() {\n        super(...arguments);\n        Listener.attach(this);\n        \n        this.type = \"player\";\n\n        this.static = true;\n        this.hidden = true;\n        this.width = 0.75;\n        this.height = 0.75;\n\n        this.speed = 1.8;\n        this.swimSpeed = 0.95;\n        this.jumpHeight = 21;\n        this.jumped = false;\n        this.lastJump = 0;\n\n        this.canSwim = false;\n        this.canDoubleJump = false;\n        this.canGravityJump = false;\n        this.invertedGravity = false;\n        this.spawnInvertedGravity = false;\n\n        this.killable = true;\n\n        this.airTime = 0;\n        //If jump is pressed x ms before you land on the ground you still jump\n        this.jumpForgiveness = 100;\n    }\n    \n\n    update(tilemaps) {\n        this.timeScale = 1;\n        this.canDoubleJump = false;\n        this.canGravityJump = false;\n        this.updatePhysics(tilemaps);\n        \n        if(this.y < -10) this.invertedGravity = false;\n    }\n\n    kill() {\n        this.dispatchEvent(\"death\");\n        this.x = this.spawnX;\n        this.y = this.spawnY;\n        this.motionX = 0;\n        this.motionY = 0;\n        this.invertedGravity = this.spawnInvertedGravity;\n    }\n\n    win() {\n        this.dispatchEvent(\"win\");\n    }\n\n    move(x = 0, jump = false) {\n        if(this.static) return;\n        \n        Entity.gravity = this.invertedGravity ? 0.5 : -0.5;\n\n        //Move laterally\n        this.motionX += x * this.speed;\n\n        if(this.canSwim) {\n            if(jump) {\n                this.motionY -= 1;\n            }\n            this.motionY *= this.swimSpeed * (this.invertedGravity ? -1 : 1);\n            this.motionX *= this.swimSpeed * (this.invertedGravity ? -1 : 1);\n        } else {\n            \n            const canJump = this.airTime < 0.06 || this.canDoubleJump;\n\n            //Jump if on ground\n            if(canJump && jump && !this.jumped) {\n                this.motionY = this.jumpHeight * (this.invertedGravity ? 1 : -1);\n            }\n            //Gravity jump\n            if(this.canGravityJump && jump && !this.jumped) {\n                this.invertedGravity = !this.invertedGravity;\n            }\n            //Jump if button pressed \"jumpForgiveness\" ms before player landed on the ground\n            if(performance.now() - this.lastJump < this.jumpForgiveness && canJump) {\n                this.motionY = this.jumpHeight * (this.invertedGravity ? 1 : -1);\n            }\n\n            //Tracks the last time the spacebar was pressed (used for jump forgiveness)\n            if(jump != this.jumped) {\n                if(jump) {\n                    this.lastJump = performance.now();\n                }\n                this.jumped = jump;\n            }\n        }\n    }\n}\n\nmodule.exports = Player;\n\n//# sourceURL=webpack://arlosmod/./client/entities/player.js?");

/***/ }),

/***/ "./client/entities/selecteditem.js":
/*!*****************************************!*\
  !*** ./client/entities/selecteditem.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\n\nclass SelectedItem extends Entity {\n    constructor() {\n        super(...arguments);\n        \n        this.type = \"selecteditem\";\n        this.width = 1;\n        this.height = 1;\n        this.useGravity = false;\n        this.static = true;\n        \n        this.tickInEditor = true;\n    }\n\n    update(tilemaps) {\n        this.updatePhysics(tilemaps);\n    }\n}\n\nmodule.exports = SelectedItem;\n\n//# sourceURL=webpack://arlosmod/./client/entities/selecteditem.js?");

/***/ }),

/***/ "./client/entities/spawnflag.js":
/*!**************************************!*\
  !*** ./client/entities/spawnflag.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Entity = __webpack_require__(/*! ./entity.js */ \"./client/entities/entity.js\");\n\nclass SpawnFlag extends Entity {\n    constructor() {\n        super(...arguments);\n        \n        this.type = \"spawnflag\";\n        this.useGravity = false;\n        this.static = true;\n        \n        this.tickInEditor = true;\n    }\n}\n\nmodule.exports = SpawnFlag;\n\n//# sourceURL=webpack://arlosmod/./client/entities/spawnflag.js?");

/***/ }),

/***/ "./client/entityhandler.js":
/*!*********************************!*\
  !*** ./client/entityhandler.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Hasher = __webpack_require__(/*! js-sha256 */ \"./node_modules/js-sha256/src/sha256.js\");\n\nfunction* idGenerator() {\n    let n = 0;\n    while(true) {\n        let v = n++;\n        let hash = Hasher.sha256(`${v}`);\n        yield hash.substr(0,16);\n    }\n}\n\nclass EntityHandler {\n    static entities = new Map();\n    static idGen = idGenerator();\n    static entityTypes = {};\n\n    static registerEntity(type) {\n\n        //Check purity\n        const te = new TypeError(\"Entity is not of type class\");\n        if(typeof type != \"function\") throw te;\n        try {void new type()} catch(e) {\n            throw te;\n        }\n        \n        this.entityTypes[type.name] = type;\n    }\n\n    static removeEntity(id) {\n        //Find entity in list and kill it\n        const ent = this.entities.get(id);\n        if(!ent) return;\n\n        ent.kill();\n        this.entities.delete(id);\n    }\n\n    static spawnEntity(ent, x, y, options = {}) {\n        if(typeof ent != \"function\") ent = this.entityTypes[ent];\n        console.log(this.entityTypes, ent, this.entityTypes[ent]);\n        if(!ent) throw new TypeError(\"Entity not of type class or not found in class list\");\n        \n        //Create new instance of the entity\n        const instance = new ent(x,y);\n        Object.assign(instance, options);\n        instance.createCollider();\n\n        const id = this.idGen.next().value;\n        instance.id = id;\n\n        this.entities.set(id, instance);\n        return instance;\n    }\n    static loadDefault() {\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/bouncyball.js */ \"./client/entities/bouncyball.js\"));\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/fireball.js */ \"./client/entities/fireball.js\"));\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/key.js */ \"./client/entities/key.js\"));\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/player.js */ \"./client/entities/player.js\"));\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/selecteditem.js */ \"./client/entities/selecteditem.js\"));\n        EntityHandler.registerEntity(__webpack_require__(/*! ./entities/spawnflag.js */ \"./client/entities/spawnflag.js\"));\n    }\n}\n\n\n\nmodule.exports = EntityHandler;\n\n//# sourceURL=webpack://arlosmod/./client/entityhandler.js?");

/***/ }),

/***/ "./client/input.js":
/*!*************************!*\
  !*** ./client/input.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Listener = __webpack_require__(/*! ./listeners.js */ \"./client/listeners.js\");\nconsole.log(\"attach\");\n\nclass Input {\n    static leftMousePressed = false;\n    static rightMousePressed = false;\n    static middleMousePressed = false;\n    static mouseX = 0;\n    static mouseY = 0;\n    static keysPressed = [];\n\tstatic canvas = document.querySelector(\"canvas\")\n\n    static listen(element) {\n        Listener.attach(Input);\n\n        document.addEventListener(\"mousedown\", (e) => {\n\n            //Update respective variable\n            if(e.button == 0) this.leftMousePressed = true;\n            if(e.button == 1) this.rightMousePressed = true;\n            if(e.button == 2) this.middleMousePressed = true;\n            \n            this.changed = true;\n            this.dispatchEvent(\"mousedown\",e.button);\n            this.dispatchEvent(\"inputchanged\");\n        })\n\n        document.addEventListener(\"mouseup\", (e) => {\n\n            //Update respective variable\n            if(e.button == 0) this.leftMousePressed = false;\n            if(e.button == 1) this.rightMousePressed = false;\n            if(e.button == 2) this.middleMousePressed = false;\n            \n            this.changed = true;\n            this.dispatchEvent(\"mouseup\",e.button);\n            this.dispatchEvent(\"inputchanged\");\n        })\n\n        element.addEventListener(\"mousemove\", (e) => {\n            //Updates mouse position\n            this.mouseX = e.clientX;\n            this.mouseY = e.clientY;\n\n            this.changed = true;\n            this.dispatchEvent(\"mousemove\",this.mouseX,this.mouseY);\n            this.dispatchEvent(\"inputchanged\");\n        })\n\n        element.addEventListener(\"touchmove\", (e) => {\n            //Does the same thing as mouse position but calculates offset\n            let cvsOffset = this.canvas.getBoundingClientRect();\n            this.mouseX = e.touches[0].clientX - cvsOffset.x;\n            this.mouseY = e.touches[0].clientY - cvsOffset.y;\n\n            this.changed = true;\n            this.dispatchEvent(\"touchmove\",this.mouseX,this.mouseY);\n            this.dispatchEvent(\"mousemove\",this.mouseX,this.mouseY);\n            this.dispatchEvent(\"inputchanged\");\n        })\n\n        document.addEventListener(\"keydown\", (e) => {\n\n            //Adds key pressed to the keysPressed array if it doesn't already exist\n            let key = e.key.toLowerCase();\n            if(!this.keysPressed.includes(key)) this.keysPressed.push(key);\n            \n            this.changed = true;\n            this.dispatchEvent(\"keydown\",key);\n            this.dispatchEvent(\"inputchanged\");\n        })\n\n        document.addEventListener(\"keyup\", (e) => {\n\n            //Removes key pressed from the keysPressed array if it exists\n            let key = e.key.toLowerCase();\n            if(this.keysPressed.includes(key)) this.keysPressed.splice(this.keysPressed.indexOf(key),1);\n            \n            this.changed = true;\n            this.dispatchEvent(\"keyup\",key);\n            this.dispatchEvent(\"inputchanged\");\n        })\n    }\n}\n\nmodule.exports = Input;\n\n//# sourceURL=webpack://arlosmod/./client/input.js?");

/***/ }),

/***/ "./client/listeners.js":
/*!*****************************!*\
  !*** ./client/listeners.js ***!
  \*****************************/
/***/ ((module) => {

eval("\nconsole.log(\"attach\");\nclass Listener {\n    static attach(object) {\n        const instance = new this();\n\n        //Copies a function over with same parameters\n        const copy = (...keys) => {\n            keys.forEach(n => {\n                //Use function for argument variable\n\n                const localFunction = instance[n];\n                object[n] = (...args) => {\n                    localFunction.call(instance,...args);\n                };\n            });\n        }\n\n        void copy(\"addEventListener\",\"removeEventListener\",\"dispatchEvent\",\"waitForEvent\");\n        return instance;\n    }\n\n    constructor() {\n        this.listeners = {};\n    }\n\n    addEventListener(id, callback) {\n        //listeners[id] is an array of callbacks\n\t\tthis.listeners[id] ??= [];\n        this.listeners[id].push(callback);\n        return callback;\n    }\n    removeEventListener(id, callback) {\n\t\tif (!this.listeners[id]) return false;\n\n        //Return if event was successfully removed\n        let found = false;\n\n        //Find specified callback in listeners with id and remove it\n\t\twhile(true) {\n\t\t\tlet i = this.listeners[id].indexOf(callback);\n\t\t\tif (i === -1) break;\n\t\t\tthis.listeners[id].splice(i,1);\n\t\t\tfound = true;\n\t\t}\n\n        return found;\n    }\n    dispatchEvent(id, ...args) {\n        //Find callbacks from listener id and call them with args\n        this.listeners[id]?.forEach(callback => {\n            callback(...args);\n        })\n\n        this.listeners[\"*\"]?.forEach(callback => {\n            callback(id,...args);\n        })\n    }\n    waitForEvent(id) {\n        return new Promise((res,rej) => {\n            const listener = this.addEventListener(id, (...args)=>{\n                removeEventListener(id, listener);\n                res(...args);\n            });\n        });\n    }\n}\n\nmodule.exports = Listener;\n\n//# sourceURL=webpack://arlosmod/./client/listeners.js?");

/***/ }),

/***/ "./client/serverinterface.js":
/*!***********************************!*\
  !*** ./client/serverinterface.js ***!
  \***********************************/
/***/ ((module) => {

eval("\nconsole.log(\"attach\");\nclass ServerInterface {\n    static async post(url, data) {\n        let res = await fetch(url, {\n            method: \"post\",\n            body: JSON.stringify(data)\n        });\n\n        let resBody = await res.text();\n        try {\n            resBody = JSON.parse(resBody);\n        } catch(e) {}\n\n        const { status } = res;\n        return { body: resBody, status };\n    }\n    static async get(url, query) {\n        let q = [];\n        for(let key of Object.keys(query)) {\n            q.push(`${key}=${query[key]}`);\n        }\n        \n        if(query) url += \"?\"+q.join(\"&\");\n        \n        let res = await fetch(url, {\n            method: \"get\"\n        });\n\n        let resBody = await res.text();\n        try {\n            resBody = JSON.parse(resBody);\n        } catch(e) {}\n\n        const { status } = res;\n        return { body: resBody, status };\n    }\n\n    static async publishLevel(data) {\n        return await this.post(\"/publish\", data);\n    }\n\n    static async getLevel(id) {\n        return await this.get(\"/level\", { id });\n    }\n}\n\nmodule.exports = ServerInterface;\n\n//# sourceURL=webpack://arlosmod/./client/serverinterface.js?");

/***/ }),

/***/ "./client/tilemap.js":
/*!***************************!*\
  !*** ./client/tilemap.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const LZUTF8 = __webpack_require__(/*! lz-string */ \"./node_modules/lz-string/libs/lz-string.js\");\nconst TextConverter = __webpack_require__(/*! ../common/textconverter.js */ \"./common/textconverter.js\");\nconsole.log(\"attach\");\n\nclass Tile {\n    constructor(arr, x, y) {\n        arr = new Int8Array(arr ?? [-1, 0, false, false]);\n        this.id = arr[0];\n        this.rotation = arr[1];\n        this.flipX = arr[2];\n        this.flipY = arr[3];\n        \n        this.x = x ?? 0;\n        this.y = y ?? 0;\n    }\n}\n\nclass TileLoader {\n    static image = null;\n    static tiles = [];\n\n    //Loads an image from the specified path\n    static loadFile(filePath) {\n        return new Promise((res,rej) => {\n            const img = new Image();\n\n            img.onload = () => {\n                res(img);\n            }\n            img.onerror = (e) => {\n                rej(new Error(\"An error occured whilst loading image\"));\n            }\n\n            img.src = filePath;\n        })\n    }\n\n    //Draws, extrudes, and stitches textures into a single atlas\n    static calculateTiles(image, options) {\n        options ??= {};\n\n        //Default options\n        options.width ??= 16;\n        options.height ??= 16;\n        options.extrude ??= 1;\n        options.sliceDirection ??= \"horizontal\";\n\n        //Calculate tile dimensions\n        const hTiles = Math.floor(image.width / options.width);\n        const vTiles = Math.floor(image.height / options.height);\n\n        const imageWidth = (options.width + options.extrude * 2) * hTiles;\n        const imageHeight = (options.height + options.extrude * 2) * vTiles;\n\n        const drawingTiles = Array(hTiles * vTiles);\n\n        //Create a canvas for the atlas\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imageWidth;\n        canvas.height = imageHeight;\n        \n        const ctx = canvas.getContext(\"2d\");\n\n        //Enable point sampling instead of billinear\n        ctx.imageSmoothingEnabled = false;\n\n        for(let tileX = 0; tileX < hTiles; tileX++) {\n            for(let tileY = 0; tileY < vTiles; tileY++) {\n\n                //Get index of tile (based on slice direction: horizontal or vertical)\n                const index = options.sliceDirection == \"horizontal\" ? ( tileX + tileY * hTiles ) : ( tileY + tileX * vTiles );\n                if(index >= options.tileCount) continue;\n\n                //Corresponding x and y positions on the canvas to the image\n                const x = (options.width + options.extrude * 2) * tileX + options.extrude;\n                const y = (options.height + options.extrude * 2) * tileY + options.extrude;\n\n                //Draw image to canvas with spacing of double extrusion\n                ctx.drawImage(image,\n                    tileX * options.width, tileY * options.height,\n                    options.width, options.height,\n                    x, y,\n                    options.width, options.height\n                );\n\n                //Coordinates for drawing image\n                drawingTiles[index] = {\n                    sx: x,\n                    sy: y,\n                    sw: options.width,\n                    sh: options.height\n                };\n            }\n        }\n\n        //Extrude left\n        for(let x = 0; x < hTiles; x++) {\n            let sx = (options.width + options.extrude * 2) * x + options.extrude;\n            let dx = sx - options.extrude;\n            ctx.drawImage(canvas,\n                sx, 0,\n                1, imageHeight,\n                dx, 0,\n                options.extrude, imageHeight\n            )\n        }\n\n        //Extrude right\n        for(let x = 0; x < hTiles; x++) {\n            let sx = (options.width + options.extrude * 2) * x + options.extrude + (options.width - 1);\n            let dx = sx + 1;\n            ctx.drawImage(canvas,\n                sx, 0,\n                1, imageHeight,\n                dx, 0,\n                options.extrude, imageHeight\n            )\n        }\n\n        //Extrude top\n        for(let y = 0; y < vTiles; y++) {\n            let sy = (options.height + options.extrude * 2) * y + options.extrude;\n            let dy = sy - options.extrude;\n            ctx.drawImage(canvas,\n                0, sy,\n                imageWidth, 1,\n                0, dy,\n                imageWidth, options.extrude\n            )\n        }\n\n        //Extrude bottom\n        for(let y = 0; y < vTiles; y++) {\n            let sy = (options.height + options.extrude * 2) * y + options.extrude + (options.height - 1);\n            let dy = sy + 1;\n            ctx.drawImage(canvas,\n                0, sy,\n                imageWidth, 1,\n                0, dy,\n                imageWidth, options.extrude\n            )\n        }\n\n        //Create tile data\n        const tiles = {};\n        drawingTiles.forEach((uv, i) => {\n            tiles[i] = {uv};\n        })\n\n\n        //Convert canvas to static image\n        const newImage = new Image();\n        newImage.src = canvas.toDataURL();\n        return new Promise((res,rej) => {\n            newImage.onload = () => {\n                res([newImage, tiles]);\n            }\n            newImage.onerror = () => {\n                rej(new Error(\"An error occured whilst calculating texture\"));\n            }\n        })\n    }\n}\n\n//Returns default texture options\nfunction defTexOpt(textureOptions) {\n    let { src, tileWidth, tileHeight, textureExtrusion, sliceDirection, tileCount } = textureOptions ?? {};\n    src ??= \"tilemap.png\";\n    tileWidth ??= 16;\n    tileHeight ??= 16;\n    textureExtrusion ??= 1;\n    sliceDirection = sliceDirection == \"vertical\" ? \"vertical\" : \"horizontal\";\n    tileCount ??= Infinity;\n\n    return { src, tileWidth, tileHeight, textureExtrusion, sliceDirection, tileCount }\n}\n\nclass Tilemap {\n    constructor(width, height, textureOptions, canvas) {\n\n        //Called on texture load and error\n        this.onload = () => {};\n        this.onerror = () => {};\n\n        //Load canvas or create new one\n        this.canvas ??= document.createElement(\"canvas\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        \n        this.textureOptions = defTexOpt(textureOptions);\n        let { src, tileWidth, tileHeight, textureExtrusion, sliceDirection, tileCount } = this.textureOptions;\n\n        //Load texture later\n        this.texture = { src };\n        this.tileSize = [ tileWidth, tileHeight, textureExtrusion ];\n        \n        //If there are no texture options then setTexture() will likely be called\n        if(textureOptions) this.reloadTexture().then(r=>this.onload(r)).catch(this.onerror);\n\n        //Copy parameters\n        this.width = width;\n        this.height = height;\n        this.blocks = Object.seal(Array(this.width * this.height).fill([-1,0,false,false]));\n\n        this.canvas.width = this.width * tileWidth;\n        this.canvas.height = this.height * tileHeight;\n    }\n\n    setTexture(textureOptions) {\n        //Load texture using options from this.textureOptions\n        this.textureOptions = defTexOpt(textureOptions);\n        let { src, tileWidth, tileHeight, textureExtrusion, sliceDirection, tileCount } = this.textureOptions;\n\n        this.texture = { src };\n        this.tileSize = [ tileWidth, tileHeight, textureExtrusion ];\n        \n        return new Promise((res,rej) => {\n            this.reloadTexture()\n            .then((r) => {\n                this.onload(r);\n                res(r);\n            }).catch((e) => {\n                this.onerror(e);\n                rej(e);\n            });\n        })\n    }\n\n    async reloadTexture(src) {\n        const [ width, height, extrude ] = this.tileSize;\n        const { sliceDirection, tileCount } = this.textureOptions;\n\n        //Load texture from file and calculate uvs\n        this.texture = await TileLoader.loadFile(src ?? this.texture.src);\n        const [ texture, tiles ] = await TileLoader.calculateTiles(this.texture, { width, height, extrude, sliceDirection, tileCount });\n        this.texture = texture;\n        this.tiles = tiles;\n\n        return [ texture, tiles ];\n    }\n\n    save() {\n        const blockArr = new Uint8Array(Math.ceil(this.blocks.length / 4) * 4);\n        let block;\n        for(let i in this.blocks) {\n            block = this.blocks[i];\n            blockArr[i] = (block[0]+1) * 4 + block[1];\n        }\n\n        let asciistring = TextConverter.uint8ToAscii(blockArr);\n        let encoded = LZUTF8.compress(asciistring);\n\n        return encoded;\n    }\n\n    load(encoded) {\n        let blockArr = TextConverter.asciiToUint8(LZUTF8.decompress(encoded));\n\n        const blocks = new Array(this.width * this.height);\n        for(let i = 0; i < this.width * this.height; i++) {\n            const id = Math.floor(blockArr[i] / 4) - 1;\n            const rotation = blockArr[i] % 4;\n            blocks[i] = new Int8Array([id, rotation, 0, 0]);\n        }\n        console.log(blocks);\n\n        this.blocks = blocks;\n        this.reconstruct();\n    }\n\n    tileInBounds(x, y) {\n        return !(x >= this.width || x < 0 || y >= this.height || y < 0);\n    }\n\n    //Sets a tile without redrawing it\n    setTileRaw(x, y, id, rotation, flipX, flipY) {\n        const index = x + y * this.width;\n        const existingTile = this.blocks[index];\n\n        id ??= existingTile[0];\n        rotation ??= existingTile[1];\n        flipX ??= existingTile[2];\n        flipY ??= existingTile[3];\n        const tile = new Int8Array([ id, rotation, flipX, flipY ]);\n        \n        this.blocks[index] = tile;\n    }\n\n    //Changes a tile and redraws it\n    setTile(x, y, id, rotation, flipX, flipY) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n        if(!this.tileInBounds(x, y)) return;\n\n        this.setTileRaw(x, y, id, rotation, flipX, flipY);\n        this.refreshTile(x,y);\n    }\n\n    //Gets a tile and creates a new Tile object which stores easier-to-read id and rotation data\n    getTile(x, y) {\n        x = Math.floor(x);\n        y = Math.floor(y);\n        if(!this.tileInBounds(x, y)) return new Tile(null, x, y);\n\n        return new Tile(this.blocks[x + y * this.width], x, y);\n    }\n\n    //Converting coordinates to the screen or world\n    screenToMap(x,y) {\n        return [Math.floor(x / this.textureOptions.tileWidth), Math.floor(y / this.textureOptions.tileWidth)];\n    }\n    mapToScreen(x,y) {\n        return [x * this.textureOptions.tileWidth, y * this.textureOptions.tileWidth];\n    }\n\n    getTileImage(id) {\n        const c = document.createElement(\"canvas\");\n        const ctx = c.getContext(\"2d\");\n\n        const tile = this.tiles[id] ?? this.tiles[0];\n        const uv = tile.uv;\n\n        c.width = uv.sw;\n        c.height = uv.sh;\n        ctx.drawImage(this.texture, uv.sx, uv.sy, uv.sw, uv.sh, 0, 0, uv.sw, uv.sh);\n\n        return c.toDataURL();\n    }\n\n    //Redraws a tile\n    refreshTile(x,y) {\n        const block = this.blocks[x + y * this.width];\n\n        //Gets tile uv coordinates in the tilemap texture\n        const tile = this.tiles[block[0]] ?? this.tiles[0];\n        const uv = tile.uv;\n        \n        //Rotates and flips the tile\n        this.ctx.setTransform(block[2] * 2 - 1, 0, 0, block[3] * 2 - 1, x * uv.sw + uv.sw/2, y * uv.sh + uv.sh/2);\n        this.ctx.rotate(block[1] * (Math.PI/2) + Math.PI);\n\n        //Remove pixels from that spot and replace them with the ones from the uv coordinates\n        this.ctx.clearRect(-uv.sw/2, -uv.sh/2, uv.sw, uv.sh);\n        if(block[0] != -1) this.ctx.drawImage(this.texture, uv.sx, uv.sy, uv.sw, uv.sh, -uv.sw/2, -uv.sh/2, uv.sw, uv.sh);\n    }\n\n    //Checks if a point is colliding with any blocks\n    colliding(x, y) {\n        const tile = this.getTile(x,y);\n        const collide = tile.id != -1;\n        return [collide, tile];\n    }\n\n    //Completely redraws the entire tilemap\n    reconstruct() {\n        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);\n\n        for(let x = 0; x < this.width; x++) {\n            for(let y = 0; y < this.height; y++) {\n                const block = this.blocks[x + y * this.width];\n\n                if(block[0] == -1) continue;\n\n                //Gets block uvs\n                const tile = this.tiles[block[0]] ?? this.tiles[0];\n                const uv = tile.uv;\n                \n                //Rotates and flips the tile\n                this.ctx.setTransform(block[2] * 2 - 1, 0, 0, block[3] * 2 - 1, x * uv.sw + uv.sw/2, y * uv.sh + uv.sh/2);\n                this.ctx.rotate(block[1] * (Math.PI/2) + Math.PI);\n\n                //Draws the tile\n                this.ctx.drawImage(this.texture, uv.sx, uv.sy, uv.sw, uv.sh, -uv.sw/2, -uv.sh/2, uv.sw, uv.sh);\n            }\n        }\n\n        //Reset transformations\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.rotate(0);\n    }\n\n    //Loops through every tile and calls callback\n    fill(callback) {\n        this.blocks.forEach((val, index) => {\n            const x = index % this.width;\n            const y = Math.floor(index / this.width);\n            this.setTileRaw(x, y, ...callback(x, y, index));\n        })\n\n        //Redraw at the end for more efficiency\n        this.reconstruct();\n    }\n}\n\nmodule.exports = Tilemap;\n\n//# sourceURL=webpack://arlosmod/./client/tilemap.js?");

/***/ }),

/***/ "./client/viewport.js":
/*!****************************!*\
  !*** ./client/viewport.js ***!
  \****************************/
/***/ ((module) => {

eval("\nconsole.log(\"attach\");\nclass Viewport {\n    constructor(x, y, zoom, scale) {\n        //Scale is world space to pixel scale (example: 16 for 16 pixels per world unit)\n        this.scale = scale ?? 1;\n\n        //Viewport transforms\n        this.x = x ?? 0;\n        this.y = y ?? 0;\n        this.zoom = zoom ?? 1;\n    }\n    get properties() {\n        const me = new Viewport();\n        me._x = this._x;\n        me._y = this._y;\n        me.zoom = this.zoom;\n        me.scale = this.scale;\n        return me;\n    }\n    set properties(me) {\n        this._x = me._x;\n        this._y = me._y;\n        this.zoom = me.zoom;\n        this.scale = me.scale;\n    }\n    get x() {\n        return this._x / this.scale;\n    }\n    get y() {\n        return this._y / this.scale;\n    }\n    set x(x) {\n        this._x = x * this.scale;\n    }\n    set y(y) {\n        this._y = y * this.scale;\n    }\n}\n\nmodule.exports = Viewport;\n\n//# sourceURL=webpack://arlosmod/./client/viewport.js?");

/***/ }),

/***/ "./common/textconverter.js":
/*!*********************************!*\
  !*** ./common/textconverter.js ***!
  \*********************************/
/***/ ((module) => {

eval("const chars = \"☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼!\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇméâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜¬╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ \";\n\nclass TextConverter {\n    static uint8ToAscii(array) {\n        if(!array instanceof Uint8Array) return null;\n\n        let result = \"\";\n        for(let i = 0; i < array.length; i++) {\n            result += chars[array[i]];\n        }\n\n        return result;\n    }\n    static asciiToUint8(str) {\n        if(typeof str != \"string\") return null;\n\n        let result = [];\n        for(let i = 0; i < str.length; i++) {\n            result.push(chars.indexOf(str[i]));\n        }\n\n        return new Uint8Array(result);\n    }\n}\n\nmodule.exports = TextConverter;\n\n//# sourceURL=webpack://arlosmod/./common/textconverter.js?");

/***/ }),

/***/ "./node_modules/js-sha256/src/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/js-sha256/src/sha256.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.9.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && \"object\" === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n    method.create = function () {\n      return new Sha256(is224);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else { // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n          blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n          blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,\n      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n      t1 = blocks[j - 2];\n      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n        this.first = false;\n      } else {\n        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));\n        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));\n        ab = a & b;\n        maj = ab ^ (a & c) ^ bc;\n        ch = (e & f) ^ (~e & g);\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));\n      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));\n      da = d & a;\n      maj = da ^ (d & b) ^ ab;\n      ch = (h & e) ^ (~h & f);\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));\n      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));\n      cd = c & d;\n      maj = cd ^ (c & a) ^ da;\n      ch = (g & h) ^ (~g & e);\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));\n      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));\n      bc = b & c;\n      maj = bc ^ (b & d) ^ cd;\n      ch = (f & g) ^ (~f & h);\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +\n      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +\n      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +\n      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +\n      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +\n      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +\n      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +\n      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +\n      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];\n    if (!this.is224) {\n      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +\n        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +\n        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +\n        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var arr = [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,\n      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,\n      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF\n    ];\n    if (!this.is224) {\n      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);\n    }\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i, type = typeof key;\n    if (type === 'string') {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >> 12));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >> 18));\n          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = (new Sha256(is224, true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha256 = exports.sha256;\n    root.sha224 = exports.sha224;\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return exports;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n\n\n//# sourceURL=webpack://arlosmod/./node_modules/js-sha256/src/sha256.js?");

/***/ }),

/***/ "./node_modules/lz-string/libs/lz-string.js":
/*!**************************************************!*\
  !*** ./node_modules/lz-string/libs/lz-string.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n\n//# sourceURL=webpack://arlosmod/./node_modules/lz-string/libs/lz-string.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./client/editor/main.js");
/******/ 	
/******/ })()
;